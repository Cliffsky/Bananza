extends Node
class_name VoxelPicker

@export var voxel_terrain: VoxelTerrain
@onready var voxel_tool: VoxelTool = voxel_terrain.get_voxel_tool()

func peek(origin: Vector3, radius: float) -> PackedInt32Array:
	var arr: Array[int]
	var diameter: int = floori(radius) * 2
	var i_origin: Vector3i = Vector3i(origin)
	for zoff: int in range(diameter):	# X, then Y, then Z. It's easier to visualize
		for yoff: int in range(diameter):
			for xoff: int in range(diameter):
				var v_off: Vector3i = Vector3i(xoff,yoff,zoff) - Vector3i.ONE * floori(radius)
				var peek_v: Vector3i = i_origin + v_off
				if i_origin.distance_to(peek_v) <= radius:
					arr.append(voxel_tool.get_voxel(peek_v))
				else:
					arr.append(-1)
	
	return PackedInt32Array(arr)

# I'm thinking this should create an ArrayMesh made of all the voxels passed into the function
#  ...exactly what the function says it does
func create_mesh_from_voxels(types: PackedInt32Array, transform: Transform3D) -> ArrayMesh:
	assert(voxel_terrain)
	assert(voxel_terrain.mesher)
	assert(voxel_terrain.mesher is VoxelMesherBlocky)
	assert(voxel_terrain.mesher.library)
	assert(voxel_terrain.mesher.library is VoxelBlockyLibrary)
	var library: VoxelBlockyLibrary = voxel_terrain.mesher.library
	var array_meshes: Array[ArrayMesh] = []
	for i: int in range(types.size()):
		var t: int = types[i]
		if t < 0: pass
		var model: VoxelBlockyModel = library.models[t]
		var diameter: int = floori(pow(types.size(), 1.0/3.0))
		var voff: Vector3 = Vector3(i % diameter, (i / diameter) % diameter, i / diameter / diameter)
		if model is VoxelBlockyModelCube:
			var mesh = _create_cube_mesh(1.0, voff)	# I could probably just create a BoxMesh and turn it into an ArrayMesh... somehow
			array_meshes.append(mesh)
		if model is VoxelBlockyModelMesh:
			var mesh = ArrayMesh.new()
			var surface_array = []
			surface_array.resize(Mesh.ARRAY_MAX)
			surface_array[Mesh.ARRAY_VERTEX] = model.mesh.get_faces()
	var aggregation: ArrayMesh = _combine_array_meshes(array_meshes)
	return aggregation

# Generated (partially) by Claude Sonnet 4.5 [TESTED]
static func _create_cube_mesh(size: float, offset: Vector3 = Vector3.ZERO) -> ArrayMesh:
	var half_size = size / 2.0
	var min_pos = -half_size
	var max_pos = half_size
	# ^ Might have to change these values if needed
	
	# Define the 8 vertices of the cube
	#  Clanker made a fucky wucky causing the front faces to be culled, 
	#  so I put the min_pos in front. Even after reading about how OpenGL does
	#  face culling, I still don't know why this works.
	var vertices = PackedVector3Array([
		# Back face
		offset + Vector3(min_pos, min_pos, min_pos),  # 0
		offset + Vector3(max_pos, min_pos, min_pos),  # 1
		offset + Vector3(max_pos, max_pos, min_pos),  # 2
		offset + Vector3(min_pos, max_pos, min_pos),  # 3
		# Front face
		offset + Vector3(min_pos, min_pos, max_pos),  # 4
		offset + Vector3(max_pos, min_pos, max_pos),  # 5
		offset + Vector3(max_pos, max_pos, max_pos),  # 6
		offset + Vector3(min_pos, max_pos, max_pos),  # 7
	])
	
	# Define the indices for the 12 triangles (2 per face, 6 faces)
	var indices = PackedInt32Array([
		# Front face
		0, 1, 2,  2, 3, 0,
		# Right face
		1, 5, 6,  6, 2, 1,
		# Back face
		5, 4, 7,  7, 6, 5,
		# Left face
		4, 0, 3,  3, 7, 4,
		# Top face
		3, 2, 6,  6, 7, 3,
		# Bottom face
		4, 5, 1,  1, 0, 4
	])
	
	# Create normals for proper lighting
	var normals = PackedVector3Array()
	normals.resize(vertices.size())
	
	# Calculate normals per vertex (averaged from adjacent faces)
	for i in range(normals.size()):
		normals[i] = Vector3.ZERO
	
	# Simple approach: set normals based on vertex positions
	for i in range(vertices.size()):
		normals[i] = vertices[i].normalized()
	
	# Create the ArrayMesh
	var arrays = []
	arrays.resize(Mesh.ARRAY_MAX)
	arrays[Mesh.ARRAY_VERTEX] = vertices
	arrays[Mesh.ARRAY_NORMAL] = normals
	arrays[Mesh.ARRAY_INDEX] = indices
	
	var array_mesh = ArrayMesh.new()
	array_mesh.add_surface_from_arrays(Mesh.PRIMITIVE_TRIANGLES, arrays)
	
	return array_mesh

# Generated by Claude Sonnet 4.5 [NOT TESTED]
static func _combine_array_meshes(meshes: Array[ArrayMesh]) -> ArrayMesh:
	var combined_mesh = ArrayMesh.new()
	
	# Iterate through each mesh
	for mesh in meshes:
		# Each mesh can have multiple surfaces
		for surface_idx in range(mesh.get_surface_count()):
			# Get the arrays from this surface
			var arrays = mesh.surface_get_arrays(surface_idx)
			
			# Get the material if it exists
			var material = mesh.surface_get_material(surface_idx)
			
			# Add this surface to the combined mesh
			combined_mesh.add_surface_from_arrays(Mesh.PRIMITIVE_TRIANGLES, arrays)
			
			# Apply the material to the new surface
			if material:
				combined_mesh.surface_set_material(combined_mesh.get_surface_count() - 1, material)
	
	return combined_mesh

# Generated by Claude Sonnet 4.5 [NOT TESTED]
static func _merge_array_meshes(meshes: Array[ArrayMesh], transform_meshes: Array[Transform3D] = []) -> ArrayMesh:
	var combined_vertices = PackedVector3Array()
	var combined_normals = PackedVector3Array()
	var combined_uvs = PackedVector2Array()
	var combined_indices = PackedInt32Array()
	
	var vertex_offset = 0
	
	for i in range(meshes.size()):
		var mesh = meshes[i]
		var transform = transform_meshes[i] if i < transform_meshes.size() else Transform3D.IDENTITY
		
		# Process each surface
		for surface_idx in range(mesh.get_surface_count()):
			var arrays = mesh.surface_get_arrays(surface_idx)
			
			var vertices = arrays[Mesh.ARRAY_VERTEX] as PackedVector3Array
			var normals = arrays[Mesh.ARRAY_NORMAL] as PackedVector3Array
			var uvs = arrays[Mesh.ARRAY_TEX_UV] as PackedVector2Array
			var indices = arrays[Mesh.ARRAY_INDEX] as PackedInt32Array
			
			# Transform vertices and normals if needed
			for j in range(vertices.size()):
				combined_vertices.append(transform * vertices[j])
				if normals and j < normals.size():
					combined_normals.append(transform.basis * normals[j])
			
			# Copy UVs
			if uvs:
				combined_uvs.append_array(uvs)
			
			# Adjust indices by the vertex offset
			if indices:
				for idx in indices:
					combined_indices.append(idx + vertex_offset)
			else:
				# If no indices, create them
				for j in range(vertices.size()):
					combined_indices.append(vertex_offset + j)
			
			vertex_offset += vertices.size()
	
	# Create the combined mesh
	var arrays = []
	arrays.resize(Mesh.ARRAY_MAX)
	arrays[Mesh.ARRAY_VERTEX] = combined_vertices
	if combined_normals.size() > 0:
		arrays[Mesh.ARRAY_NORMAL] = combined_normals
	if combined_uvs.size() > 0:
		arrays[Mesh.ARRAY_TEX_UV] = combined_uvs
	arrays[Mesh.ARRAY_INDEX] = combined_indices
	
	var merged_mesh = ArrayMesh.new()
	merged_mesh.add_surface_from_arrays(Mesh.PRIMITIVE_TRIANGLES, arrays)
	
	return merged_mesh
